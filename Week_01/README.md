##master theorem 主定理 important
##### D1 : 非空子串的个数共有 n(n+1)/2 
##### D2 : 懵的时候的基本思路：
           1 尝试思考暴力解决
           2 尝试通过基本问题，利用数学归纳法找出规律
           3 寻找最近 重复 子问题 /分而治之（基础循环/递归/动态规划）
           4 双指针 收敛渐进，减少单向循环的次数
           5 填充/替换
           
##### D3 : 算法优化基本考虑方向  1 - 空间换时间   2 - 升维

##### D5 : 优先队列/双端队列 (深入了解)
           Tip ：1 > 优先队列priority queue 实现主要通过heap
                 但heap实现也较为多样，比如二叉树，二叉搜索树，fibo堆等，不可拘泥于某种
                 
                 2 > 3sum问题:重复结果集 是通过（排序+索引前后比对，跳过重复值）
                 
                 3 > linkedList operate 注意前后指针的调换，若处理问题时，两个元素调换整体代码编写较为复杂 
                 考虑增加额外结构（包含linkedList本身），以期减少复杂度       
   
##### D6: arrayList linkedList stack queue priorityQueue deque 复杂度分析
          判断溢出 使用number/10 比max或min /10 ，如果等同，判断number%10 与 max%10或min%10 ！！！！！
##### D7:  栈使用场景判断：找最近相关性/重复性，洋葱型 ； 先进先出等用队列
          双栈实现队列  双队列实现栈  最小栈用双栈    
          最大矩形面积 ：stack    /暴力法：固定一个高度，找寻左右边界  leetcode 85 需要经常反复的看逻辑加深记忆
          入栈过程中 ，要保证栈顺序从小到大，入栈时比较左边界，如果大，说明探测到栈顶元素的右边界，可计算栈顶元素的面积，并弹出栈
          滑动窗口问题：队列-双端队列
          最小栈： 用双栈，其中一个正常存储，另一个记录每次入栈时的最小值，即用新的值对比当前最小值栈的栈顶元素
          如果大于栈顶元素，那么最小值栈再次压入当前最小值，如果小于栈顶元素，那么压入新值入最小值栈，length+=1，且正常存储栈也要入栈
          pop的时候 ，要双栈同时delete栈顶


