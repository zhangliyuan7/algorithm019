#####身高重新排队列 
    ```
    贪心, 步骤：先用身高排序，再遍历排序队列，把k当作索引插入结果集
    1 > 身高排序，同等身高，k越大越靠后
        
        	sort.Slice(people,func(i,j int )bool{
        		if people[i][0]==people[j][0]{
        			return people[i][1]<people[j][1]
        		}
        		return people[i][0]>people[j][0]
        	})
    
    2 > 循环排序好的二维数组，前面是大身高值，每个循环元素将其k值作为索引，插入结果
        将列表中k值索引整体后移一位，补位插入值i位置
            for i,v:=range people{
                    //将[ 插入位置:取出元素索引位i的前一个元素+1]的元素向后平移一位
                    // [ 插入位置后一位:取出元素的位置i+1],正好补到取出元素位
            		copy(people[v[1]+1:i+1],people[v[1]:i])
            		people[v[1]]=v
            }
    3 > 整体过程如下示例：        
        原始输入：
        [[7,0] [4,4] [7,1] [5,0] [6,1] [5,2]]
        sort处理：
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        遍历people：
        ===== i=0
           ↓：p[0] 应该在index=0的位置  p[0] = [7 0]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] 
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=1
                 ↓：p[1]应该在index=1的位置  p[1]=[7 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=2
                       ↓：p[2]应该在index=1的位置 p[2]=[6 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=3
                             ↓：p[3]应该在index=0的位置 p[3]=[5 0]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]]
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]] ok
        
        ===== i=4
                                   ↓：p[4]应该在index=2的位置  p[4]=[5 2] 
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]] ok
        
        ===== i=5
                                         ↓：p[5]应该在index=4的位置  p[5]=[4 4]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]] ok
        
        最终结果：
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]]    
    ```