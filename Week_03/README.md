学习笔记
#####身高重新排队列 
    ```
    贪心, 步骤：先用身高排序，再遍历排序队列，把k当作索引插入结果集
    1 > 身高排序，同等身高，k越大越靠后
        
        	sort.Slice(people,func(i,j int )bool{
        		if people[i][0]==people[j][0]{
        			return people[i][1]<people[j][1]
        		}
        		return people[i][0]>people[j][0]
        	})
    
    2 > 循环排序好的二维数组，前面是大身高值，每个循环元素将其k值作为索引，插入结果
        将列表中k值索引整体后移一位，补位插入值i位置
            for i,v:=range people{
                    //将[ 插入位置:取出元素索引位i的前一个元素+1]的元素向后平移一位
                    // [ 插入位置后一位:取出元素的位置i+1],正好补到取出元素位
            		copy(people[v[1]+1:i+1],people[v[1]:i])
            		people[v[1]]=v
            }
    3 > 整体过程如下示例：        
        原始输入：
        [[7,0] [4,4] [7,1] [5,0] [6,1] [5,2]]
        sort处理：
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        遍历people：
        ===== i=0
           ↓：p[0] 应该在index=0的位置  p[0] = [7 0]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] 
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=1
                 ↓：p[1]应该在index=1的位置  p[1]=[7 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=2
                       ↓：p[2]应该在index=1的位置 p[2]=[6 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=3
                             ↓：p[3]应该在index=0的位置 p[3]=[5 0]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]]
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]] ok
        
        ===== i=4
                                   ↓：p[4]应该在index=2的位置  p[4]=[5 2] 
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]] ok
        
        ===== i=5
                                         ↓：p[5]应该在index=4的位置  p[5]=[4 4]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]] ok
        
        最终结果：
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]]    
    ```

##### 身高重新排队列 
    ```
    贪心, 步骤：先用身高排序，再遍历排序队列，把k当作索引插入结果集
    1 > 身高排序，同等身高，k越大越靠后
        
        	sort.Slice(people,func(i,j int )bool{
        		if people[i][0]==people[j][0]{
        			return people[i][1]<people[j][1]
        		}
        		return people[i][0]>people[j][0]
        	})
    
    2 > 循环排序好的二维数组，前面是大身高值，每个循环元素将其k值作为索引，插入结果
        将列表中k值索引整体后移一位，补位插入值i位置
            for i,v:=range people{
                    //将[ 插入位置:取出元素索引位i的前一个元素+1]的元素向后平移一位
                    // [ 插入位置后一位:取出元素的位置i+1],正好补到取出元素位
            		copy(people[v[1]+1:i+1],people[v[1]:i])
            		people[v[1]]=v
            }
    3 > 整体过程如下示例：        
        原始输入：
        [[7,0] [4,4] [7,1] [5,0] [6,1] [5,2]]
        sort处理：
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        遍历people：
        ===== i=0
           ↓：p[0] 应该在index=0的位置  p[0] = [7 0]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] 
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=1
                 ↓：p[1]应该在index=1的位置  p[1]=[7 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=2
                       ↓：p[2]应该在index=1的位置 p[2]=[6 1]
        [[7 0] [7 1] [6 1] [5 0] [5 2] [4 4]]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]] ok
        
        ===== i=3
                             ↓：p[3]应该在index=0的位置 p[3]=[5 0]
        [[7 0] [6 1] [7 1] [5 0] [5 2] [4 4]]
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]] ok
        
        ===== i=4
                                   ↓：p[4]应该在index=2的位置  p[4]=[5 2] 
        [[5 0] [7 0] [6 1] [7 1] [5 2] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]] ok
        
        ===== i=5
                                         ↓：p[5]应该在index=4的位置  p[5]=[4 4]
        [[5 0] [7 0] [5 2] [6 1] [7 1] [4 4]]
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]] ok
        
        最终结果：
        [[5 0] [7 0] [5 2] [6 1] [4 4] [7 1]]    
    ```
    
##### 合法的n层括号全排列集合 NO.22
    ```
    1 > 左括号个数小于等于n
    2 > 右括号个数小于等于左括号，才可以继续
    3 > 右括号出现一定是存在左括号后才可以出现
    4 > 终止条件 left == right == n,此时入结果集
    
    recursion four steps：
        1 terminator
        2 process
        3 drill down
        4 recursion
    ```
##### 递归
    ```
    template：
       1 terminator
       2 process
       3 drill down
       4 recursion
    ```
##### 距离顺序排序矩阵单元
    ```
    //桶排序快 20ms
    曼哈顿距离=|(row-row)|+|(column-column)|
    桶排序 列表存储距离下标，列举所有点即可
    //BFS 慢 44ms
    BFS 上下左右点挨个扫一边，边界注意是R，C(下边界0索引要引入结果集，上边界R/C不能引入)
    visited所有坐标，因为是广度优先，每层列举都是距离未访问过的最近的点
    所以不用考虑计算实际距离，每次同时扩展的点便是同等距离的四周点
    一个遍历队列，一个访问过的确认队列，一个结果集
    直接append即可
    ```
##### use list to do Map's key, Map compares value to decide in/not in state 
    ```
    output => true
    func TestAllCellsDistOrder1(t *testing.T) {
	    var a = make(map[[2]int]bool)
	    var r = [2]int{0,1}
	    var s = [2]int{0,1}
	    a[r]=true
	    if v,ok:=a[s];ok{
	    	fmt.Println(v)
	    }
    }
    ```
##### 二叉树最大深度-递归
    ```
    递归简化一些，不断返回当前子树最大深度,递归栈因为层层引用，结束前无法释放，所以容易溢出
    important：99%的递归转非递归，都可以通过栈来进行实现
    非递归的深度优先：
        用栈，每次先将弹出元素的右子节点先压栈，后压左子节点，以此类推，非nil时临时变量+1，当遇到nil，长度变量重置 -1 
    ```
    
##### BFS，DFS 
    ```
        BFS节点遍历，使用队列，不断扩散的过程，将新访问到的节点添加到队列中，使用一个visited记录访问过的节点
        先进先出logic process
        
        DFS 则是使用栈，如树，先将右节点入栈，后入栈左节点，然后出栈，再同理处理出栈元素的左右节点，不断进行迭代
        非递归重点就是使用栈先右后左入栈，然后弹出一个元素，进行往复处理
    ```
    
##### 加油站问题 134
    ```
    累加每站的剩余量left += gas[i]-cost[i]，如果left一直大于0，则可以一直走下去
  
    
       3        4
         1 __ 2    
        /      \
    2  5        3  5
        \      /  
         `` 4 ^        
            1          
    从起点站 aa 出发，必须 left(a) = gas[a] - cost[a] >= 0left(a)=gas[a]−cost[a]>=0 才能到下一站。假设在 cc 站加完油发现去不了 dd 站，只是说明 aa 站不是起点吗？
    到不了 dd 站，有： (gas[a] - cost[a] )+ (gas[b] - cost[b])+ (gas[c] - cost[c])<0(gas[a]−cost[a])+(gas[b]−cost[b])+(gas[c]−cost[c])<0
    
    即： left(a)+ left(b)+ left(c)<0
    即：left(a)+left(b)+left(c)<0
    
    已知 ： left(a) >= 0
    已知：left(a)>=0
    
    所以： left(b)+ left(c) < 0
    所以：left(b)+left(c)<0
    
    所以，b 站不能作为起点，去不了d。
    
    能来到 c 站，肯定到过 b 站： left(a)+left(b)>=0left(a)+left(b)>=0
    
    又因为： left(a)+ left(b)+ left(c) <0
    又因为：left(a)+left(b)+left(c)<0
    
    有： left(c) < 0
    有：left(c)<0
    
    c 站也不能作为起点，去不了 d！
    
    **结论1：如果累加 gas[i]-cost[i]gas[i]−cost[i] 后，如果小于 00。则出发点到站 ii 都不能作为起点。**
    如果总加油量 sum(gas) < sum(cost)sum(gas)<sum(cost) 总耗油量，问题无解，因为油不够走完全程。
    
    如果 sum(gas) >= sum(cost)sum(gas)>=sum(cost) ，问题一定有解吗？是的，为什么呢？
    
    **结论2：如果总加油量 sum(gas) >= sum(cost)sum(gas)>=sum(cost) 总耗油量，问题一定有解。**
    我们从起点 0 开始，累加每个站点的 gas[i]-cost[i]gas[i]−cost[i]，即 left(i)left(i)
    当站 i 累加完 left(i)left(i) 后，如果小于 0，则站 0 到 站 ii 都不是起点，且 [0,i][0,i] 段的 \sum left<0∑left<0
    我们将 i+1i+1 作为起点，重新累加每个站点的 left(i)left(i)
    当站 jj 累加完 left(j)left(j)，如果小于 0，则站 i+1i+1 到站 jj 都不是起点。[i+1,j][i+1,j] 段的 \sum left<0∑left<0
    继续考察新起点……如下图
    但 sum(gas) >= sum(cost)sum(gas)>=sum(cost)，对于整个数组：\sum left>=0∑left>=0
    因此必然有一段是 \sum left>0∑left>0，假设此时起点更新为 k，以 k 为起点的这一段能加到足够的油，能填补其他段欠缺的量，绕一圈

    **反过来想**
    假设从任意点出发，均无法走完一圈，走一段就走不下去，橙色段覆盖的点都不是起点，换个起点，又走不下去，又淘汰一批点，直到绕回来，此时的点已经不能是起点。
    所有点都被橙色段覆盖，整个数组\sum left<0∑left<0，但明明 \sum left>=0∑left>=0 ，相悖。
    所以只要 sum(gas) >= sum(cost)sum(gas)>=sum(cost) ，肯定存在一个点，能走完一圈。
    
    此问题核心点：
        0 > 每次的余量只要小于0，此起点不符合要求，那么起点切换为下个点
        1 > 每次循环如果当前left gas < left cost，那么到循环的i为止，循环过的点都不可能是起点
        2 > 如果最终循环结束，total gas > total cost 那么一定存在起点,且为循环最后的start
        记录不失效的起点，最终返回。复杂度O(n)
    ```   
    
##### 分治模板，回溯（本质递归）
    ```
        分治模板类似递归模板 只是要将问题拆分成子问题，递归处理，最终进行汇总
        template:
            // 子问题/整个问题-终止条件
            terminator
            // 拆分成子问题
            process _part1
                split question -> final_question -> sub_questions
            // 对子问题递归
            drill down
                -> recursion sub_questions
            // 拼装子问题结果
            process _part2
                -> consist the sub_question's answer
            // 返回最终结果
            revert
            
        回溯则是不断向下延伸的试错过程，若遇到错误，则将此分支或者上面n步结果取消，最终获得正确结果的过程
    ```
##### 有效二叉搜索树
    ```
        中序遍历，用一个变量初始化为math.minInt64，然后不断与变量比较，递增为true，非递增则false
        中序遍历，记得left未塞完之前一定要continue，忽略导致错误了
    ```

##### pow(X,N) 分治
    ```
        不断获取x的n/2次方值，需要注意的点：
        1 > 分治终止条件
        2 > 指数为负数，返回的结果1.0/result
        3 > n/2%2!=0 要多乘一次x
    ```
    
##### 78 子集 will do
    ```
    ```
##### make package and take it back to  home  OR upload to github.com
    ```
    ```
##### n queen 回溯
    ```
    ```
##### 电话号码字母组合
    ```
    用开枝散叶的思路一步步拼接字符串，每个点分叉处理下个点的range，当没有下个字符时，返回即可
    ```
##### 排序链表 148
    ```
    归并排序，不断将链表拆分成短链表，对其排序，最后通过合并两个有序链表的方式组合起来
    关键：
        1 > 拆分链表方式，一分为二，用快慢指针，快指针到尽头，慢指针即是一半
        2 > 拆分链表成两个之后 ，一定要将中间的链接打断，否则容易出环，比如1234 拆分成12和34 则2->3一定要打断 令2->nil
        3 > 递归的终止条件，两个元素时即可排序比较，还有head==tail时，直接返回即可
        4 > 步骤：自顶向下：结果->(repeat)不断拆分链表成短链表->(repeat)合并两个有序链表->当链表元素为2或者1时，返回排序后链表 
    ```