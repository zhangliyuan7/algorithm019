学习笔记

##### 位运算
    ```
        >>  0110 -> 0011
        <<  0110 -> 1100
        n&n-1 清除最后一位的1 
        n&(-n)   ==  x & (~x + 1)
             ① 这个结果只有一位值是1， 其他位均是0 
             ② 这个值的末位0的个数与原值保持一致
            
        ^异或  相同为0 不同为1 
        x^0 = x
        x^1s = ~x  1s=～0  全零
        x^(~x) = 1s
        x^x = 0
        c=a^b => a^c =b b^c=a
        a^b^c=a^(b^c)=(a^b)^c
        x&~x = 0   
        
        x最右边的n位清零 x&(~0<<n)
        x的第n个位置 (x>>n)&1
        x的第n位的幂值 x&&(1<<n)
        将第n位置为1  x|(1<<n)
        第n位置换为0  x&(~(1<<n))
        x的最高位至第n位清零  x&((1<<n)-1)
        判断奇偶
            x&1==1 奇数
            x&1==0 偶数
        整除 
            x/2 == x>>1
        清零最低位的1
            x&(x-1)
        得到最低位的1
            x&-x
        
    ```
##### 2的幂次 231
    ```
        二进制有且仅有一个1 即为2的幂次
        二进制位消末位1 n&(n-1) 的次数即个数
        if n!=0 {
            count++
            if count>1{
                return false 
            }
            n=n&(n-1)
        }
        简化：
            if n<0{return false}
            return n&(n-1)==0
    ```
##### 1出现的次数 191 
    ```
        n&(n-1) 次数,即1的个数
    ```
##### 颠倒二进制 190
    ```
        取最后一位，倒序移位相加
        power:=31 (uint32)
        for n!=0{
            last:=n&1
            result+= last<<power
            n= n>>1
            power-=1
        }
    ```
##### bloom filter 布隆过滤器
    ```
        类似一个极速缓存，拦截在db或者缓存外边，做一个高效的粗略的过滤拦截
        对请求对象进行二进制存储，当获取到二进制位存在任何一个0 ，则可以确定该数据不在后边的db或者存储空间里，内容不存在
        当不存在0的时候，则有可能存在于后端存储，就可以允许其请求后端存储进行数据获取尝试
        优点：简单，快速，高效
        缺点：删除困难，因为有重复利用的二进制位，有一定误判率（可以确定不存在，但是不能确定一定存在）
    ```
##### LRU cache 
    ```
        最近最少使用元素
        通常由 hash map+double linkedlist实现
        查询O(1)-hash map的部分，插入和删除也是O(1) 链表的部分
        当数据进入，不断往链表顶部写入
        链表空间满时：新数据存储空间不足时，踢出链表中最尾部的元素
        当访问了存在于链表中的旧元素时，将旧元素翻新（删除该元素，重新插入回链表顶部）
        
        类似页面置换算法（LFU 最近访问频次最少元素）
    ```
    